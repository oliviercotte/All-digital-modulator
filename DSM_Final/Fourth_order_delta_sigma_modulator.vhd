-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\DSM_MOD4_HDL\Fourth_order_delta_sigma_modulator.vhd
-- Created: 2018-01-08 05:39:59
-- 
-- Generated by MATLAB 9.3 and HDL Coder 3.11
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 3.33333e-07
-- Target subsystem base rate: 3.33333e-07
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        3.33333e-07
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- Out1                          ce_out        3.33333e-07
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Fourth_order_delta_sigma_modulator
-- Source Path: DSM_MOD4_HDL/Fourth_order_delta_sigma_modulator
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Fourth_order_delta_sigma_modulator_pkg.ALL;

ENTITY Fourth_order_delta_sigma_modulator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        In1                               :   IN    std_logic_vector(35 DOWNTO 0);  -- sfix36_En32
        ce_out                            :   OUT   std_logic;
        Out1                              :   OUT   std_logic_vector(1 DOWNTO 0)  -- sfix2
        );
END Fourth_order_delta_sigma_modulator;


ARCHITECTURE rtl OF Fourth_order_delta_sigma_modulator IS

  -- Component Declarations
  COMPONENT Quantizer
    PORT( u                               :   IN    std_logic_vector(35 DOWNTO 0);  -- sfix36_En32
          y                               :   OUT   std_logic_vector(35 DOWNTO 0)  -- sfix36_En32
          );
  END COMPONENT;

  COMPONENT Sign
    PORT( u                               :   IN    std_logic_vector(35 DOWNTO 0);  -- sfix36_En32
          y                               :   OUT   std_logic_vector(1 DOWNTO 0)  -- sfix2
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Quantizer
    USE ENTITY work.Quantizer(rtl);

  FOR ALL : Sign
    USE ENTITY work.Sign(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL In1_signed                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Digital_PCM_signal               : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain8_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL delayMatch3_reg                  : vector_of_signed36(0 TO 1);  -- sfix36 [2]
  SIGNAL Gain8_out1_1                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain7_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL delayMatch2_reg                  : vector_of_signed36(0 TO 1);  -- sfix36 [2]
  SIGNAL Gain7_out1_1                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain6_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL delayMatch1_reg                  : vector_of_signed36(0 TO 1);  -- sfix36 [2]
  SIGNAL Gain6_out1_1                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain5_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL delayMatch_reg                   : vector_of_signed36(0 TO 1);  -- sfix36 [2]
  SIGNAL Gain5_out1_1                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL kconst                           : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL kconst_1                         : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Digital_PCM_signal_1             : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain_mul_temp                    : signed(71 DOWNTO 0);  -- sfix72_En64
  SIGNAL Gain_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain_out1_1                      : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL y_signed                         : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain4_mul_temp                   : signed(71 DOWNTO 0);  -- sfix72_En67
  SIGNAL Gain4_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Integrator_3                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Delay2_out1                      : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain3_mul_temp                   : signed(71 DOWNTO 0);  -- sfix72_En69
  SIGNAL Gain3_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain2_mul_temp                   : signed(71 DOWNTO 0);  -- sfix72_En71
  SIGNAL Gain2_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Integrator_1                     : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Delay_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL y                                : std_logic_vector(35 DOWNTO 0);  -- ufix36
  SIGNAL Gain1_mul_temp                   : signed(71 DOWNTO 0);  -- sfix72_En74
  SIGNAL Gain1_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Intergrator_2                    : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain9_mul_temp                   : signed(71 DOWNTO 0);  -- sfix72_En64
  SIGNAL Gain9_out1                       : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum_op_stage2                    : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sigma                            : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum1_add_temp                    : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum2_op_stage2                   : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum2_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum3_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Quantizer_input                  : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Gain10_mul_temp                  : signed(71 DOWNTO 0);  -- sfix72_En64
  SIGNAL Gain10_out1                      : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum4_op_stage2                   : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum4_op_stage3                   : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum4_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum6_op_stage2                   : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum6_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL Sum7_out1                        : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL y_1                              : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL y_2                              : signed(35 DOWNTO 0);  -- sfix36_En32

BEGIN
  u_Quantizer : Quantizer
    PORT MAP( u => std_logic_vector(Quantizer_input),  -- sfix36_En32
              y => y  -- sfix36_En32
              );

  u_Sign : Sign
    PORT MAP( u => y,  -- sfix36_En32
              y => y_1  -- sfix2
              );

  In1_signed <= signed(In1);

  Digital_PCM_signal <= In1_signed;

  Gain8_out1 <= to_signed(0, 36);

  enb <= clk_enable;

  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch3_reg <= (OTHERS => to_signed(0, 36));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch3_reg(0) <= Gain8_out1;
        delayMatch3_reg(1) <= delayMatch3_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch3_process;

  Gain8_out1_1 <= delayMatch3_reg(1);

  Gain7_out1 <= to_signed(0, 36);

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg <= (OTHERS => to_signed(0, 36));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch2_reg(0) <= Gain7_out1;
        delayMatch2_reg(1) <= delayMatch2_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  Gain7_out1_1 <= delayMatch2_reg(1);

  Gain6_out1 <= to_signed(0, 36);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => to_signed(0, 36));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= Gain6_out1;
        delayMatch1_reg(1) <= delayMatch1_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  Gain6_out1_1 <= delayMatch1_reg(1);

  Gain5_out1 <= to_signed(0, 36);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => to_signed(0, 36));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= Gain5_out1;
        delayMatch_reg(1) <= delayMatch_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Gain5_out1_1 <= delayMatch_reg(1);

  kconst <= to_signed(23486462, 36);

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      kconst_1 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        kconst_1 <= kconst;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Digital_PCM_signal_1 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Digital_PCM_signal_1 <= Digital_PCM_signal;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Gain_mul_temp <= kconst_1 * Digital_PCM_signal_1;
  Gain_out1 <= Gain_mul_temp(67 DOWNTO 32);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Gain_out1_1 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Gain_out1_1 <= Gain_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Gain4_mul_temp <= signed'(X"480B5A896") * y_signed;
  Gain4_out1 <= Gain4_mul_temp(70 DOWNTO 35);

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_out1 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay2_out1 <= Integrator_3;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  Gain3_mul_temp <= signed'(X"73A9FB75E") * y_signed;
  Gain3_out1 <= resize(Gain3_mul_temp(71 DOWNTO 37), 36);

  Gain2_mul_temp <= signed'(X"6C08210E3") * y_signed;
  Gain2_out1 <= resize(Gain2_mul_temp(71 DOWNTO 39), 36);

  Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_out1 <= Integrator_1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  y_signed <= signed(y);

  Gain1_mul_temp <= signed'(X"5997FF6AE") * y_signed;
  Gain1_out1 <= resize(Gain1_mul_temp(71 DOWNTO 42), 36);

  Gain9_mul_temp <= to_signed(19132326, 36) * Intergrator_2;
  Gain9_out1 <= Gain9_mul_temp(67 DOWNTO 32);

  Sum_op_stage2 <= Gain_out1_1 - Gain9_out1;

  Sigma <= Sum_op_stage2 - Gain1_out1;

  Sum1_add_temp <= Gain5_out1_1 + Sigma;
  Integrator_1 <= Sum1_add_temp + Delay_out1;

  Sum2_op_stage2 <= Gain6_out1_1 + Integrator_1;

  Sum2_out1 <= Sum2_op_stage2 - Gain2_out1;

  Sum3_out1 <= Sum2_out1 + Intergrator_2;

  Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Intergrator_2 <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Intergrator_2 <= Sum3_out1;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  Gain10_mul_temp <= to_signed(122497865, 36) * Quantizer_input;
  Gain10_out1 <= Gain10_mul_temp(67 DOWNTO 32);

  Sum4_op_stage2 <= Gain7_out1_1 - Gain10_out1;

  Sum4_op_stage3 <= Sum4_op_stage2 + Intergrator_2;

  Sum4_out1 <= Sum4_op_stage3 - Gain3_out1;

  Integrator_3 <= Sum4_out1 + Delay2_out1;

  Sum6_op_stage2 <= Gain8_out1_1 + Integrator_3;

  Sum6_out1 <= Sum6_op_stage2 - Gain4_out1;

  Sum7_out1 <= Sum6_out1 + Quantizer_input;

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Quantizer_input <= to_signed(0, 36);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Quantizer_input <= Sum7_out1;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  ce_out <= clk_enable;

  Out1 <= y_1;

END rtl;

